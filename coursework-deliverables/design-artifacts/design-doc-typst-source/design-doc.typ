#import "@preview/tablex:0.0.6": tablex, rowspanx, colspanx

#set document(title: "GlobalBooks SOA Implementation", author: "CCS3341 Coursework")
#set page(numbering: "1", number-align: center)
#set heading(numbering: "1.")

// Title page
#align(center)[
  #text(24pt, weight: "bold")[GlobalBooks SOA Implementation]
  
  #v(1cm)
  
  #text(16pt)[CCS3341 SOA & Microservices Coursework]
  
  #v(2cm)
  
  #text(12pt)[
    *Module:* CCS3341 SOA & Microservices \
    *Assessment:* Coursework (60%) \
    *Date:* September 3, 2025 \
    *Name:* M C R Mallawaarachchi \
    *Index:* 22ug1-0093
  ]
]

#pagebreak()

#outline(depth: 2)

#pagebreak()

= Task 1: SOA Design Principles

== Service Decomposition Applied

*Principles Used:*
- *Service Autonomy*: Each service owns its data and logic
- *Loose Coupling*: Services communicate via contracts only
- *Single Responsibility*: One business capability per service
- *Service Abstraction*: Internal implementation hidden

== Service Breakdown

```
Monolith → Six Autonomous Services:

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Auth (8081) │    │Catalog(8085)│    │Orders(8082) │
│- Users      │    │- Books      │    │- Lifecycle  │
│- JWT tokens │    │- Inventory  │    │- Persistence│
└─────────────┘    └─────────────┘    └─────────────┘

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│Payment(8083)│    │Ship'g(8084) │    │Orchestr(8086│
│- Transacts  │    │- Logistics  │    │- Workflows  │
│- Processing │    │- Tracking   │    │- Integration│
└─────────────┘    └─────────────┘    └─────────────┘
```

*Implementation Evidence:*
- Independent H2 databases per service
- Separate Spring Boot applications
- No shared code or direct database access
- Message-based communication via RabbitMQ

= Task 2: Benefits and Challenges

== Key Benefit: Independent Scalability
- Scale catalog service during peak browsing
- Scale payment service during checkout surges
- Deploy services independently
- Technology diversity possible

== Primary Challenge: Distributed Complexity
- Network latency and failures
- Data consistency across services
- Debugging distributed workflows
- Operational overhead (6 services vs 1)

*Mitigation Strategies:*
- Health checks and circuit breakers
- Message queuing for reliability
- Centralized logging
- Automated testing suite

= Task 3: WSDL Excerpt for CatalogService

== CatalogService WSDL and Schema Files

*Service Configuration:*
- *Target Namespace:* `http://globalbooks.com/catalog`
- *Operation:* `getBookDetails` 
- *Endpoint:* `http://localhost:8085/ws`
- *WSDL Location:* `http://localhost:8085/ws/books.wsdl`

*Design Artifacts:*
- `design-artifacts/catalog-service.wsdl` - Complete WSDL definition for catalog service
- `design-artifacts/catalog-service.xsd` - XML Schema definition for catalog operations
- `design-artifacts/order-process.wsdl` - WSDL definition for order-orchestration-service SOAP endpoint
- `design-artifacts/order-process.xsd` - XML Schema for order orchestration operations

*Service Description:*
- *Messages:* `getBookDetailsRequest`, `getBookDetailsResponse`
- *PortType:* `BooksPort` with `getBookDetails` operation
- *Binding:* SOAP 1.1 document/literal style
- *Data Types:* Book entity (id, title, author)

*Implementation Location:*
- Source: `catalog-service/src/main/resources/books.xsd`
- Config: `catalog-service/src/main/java/.../WebServiceConfig.java`
- Runtime: Auto-generated by Spring Web Services

= Task 4: UDDI Registry Entry

== Service Discovery Metadata

*UDDI Entry Structure:*
```
Business Entity: GlobalBooks Inc.
  └── Service: CatalogService
      ├── Description: Book catalog management
      ├── Categories: E-commerce, SOAP
      └── Binding Template
          ├── WSDL: http://localhost:8085/ws/books.wsdl
          ├── Endpoint: http://localhost:8085/ws
          └── Transport: SOAP/HTTP
```
- Complete metadata in `design-artifacts/uddi-entries.xml`

*Modern Alternative:*
- UDDI replaced by service mesh (Kubernetes, Istio)
- API Gateway registration

= Task 5: CatalogService SOAP Implementation

== Spring Web Services Implementation

*Configuration:*
```java
@EnableWs
@Configuration
public class WebServiceConfig extends WsConfigurerAdapter {
    
    @Bean
    public ServletRegistrationBean messageDispatcherServlet() {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        return new ServletRegistrationBean(servlet, "/ws/*");
    }
    
    @Bean(name = "books")
    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema booksSchema) {
        // WSDL generation from XSD schema
        return wsdl11Definition;
    }
}
```

*SOAP Endpoint:*
```java
@Endpoint
@Component
public class BookEndpoint {
    
    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "getBookDetailsRequest")
    @ResponsePayload
    public GetBookDetailsResponse getBookDetails(@RequestPayload GetBookDetailsRequest request) {
        // Business logic implementation
        return response;
    }
}
```

*Configuration Files:*
- Spring Boot auto-configuration (no web.xml needed)
- Maven JAXB2 plugin for code generation
- Available in `configuration-files/catalog-service-application.properties`

= Task 6: SOAP Testing

== Testing Strategy

*Automated Testing Approach:*
- Shell scripts instead of SOAP UI for easlier CI/CD integration
- Comprehensive test assertions
- XML validation and parsing

*Test Implementation:*
```bash
# Test script: test-4-catalog-service.sh
curl -X POST http://localhost:8085/ws \
  -H "Content-Type: text/xml; charset=utf-8" \
  -d 'SOAP_ENVELOPE_XML'

# Validations:
# - HTTP 200 response
# - Valid SOAP envelope structure  
# - Correct book data returned
# - Error handling for invalid requests
```

*Test Suite Available:*
- `test-4-catalog-service.sh` - Direct SOAP testing
- `run-all-tests.sh` - Complete automation
- Response validation and error testing

= Task 7: OrdersService REST API

== REST Endpoint Design

*Orders Service Endpoints (Port 8082):*
- `POST /orders` - Create new order
- `GET /orders/{id}` - Retrieve specific order by ID
- `GET /orders` - List all orders
- `GET /health` - Service health check

== Sample JSON Request/Response

*Create Order Request (POST /orders):*
```json
{
  "id": null,
  "bookIsbns": ["978-0134685991"],
  "customerId": "customer123"
}
```

*Create Order Response (200 OK):*
```json
{
  "id": 1,
  "bookIsbns": ["978-0134685991"],
  "customerId": "customer123",
  "bookDetails": {
    "paymentStatus": "PENDING",
    "shippingStatus": "PENDING"
  }
}
```

*Get Order Response (GET /orders/1):*
```json
{
  "id": 1,
  "bookIsbns": ["978-0134685991"],
  "customerId": "customer123",
  "bookDetails": {
    "paymentStatus": "PAID",
    "shippingStatus": "SHIPPED"
  }
}
```

== JSON Schema Definition

*Order Object Schema:*
- *id*: Integer, auto-generated primary key
- *bookIsbns*: String array, required - ISBN identifiers for books
- *customerId*: String, required - Customer identifier
- *bookDetails*: Object, optional - Order status information
  - *paymentStatus*: String - PENDING, PAID, FAILED
  - *shippingStatus*: String - PENDING, SHIPPED, DELIVERED

*Validation Rules:*
- bookIsbns array cannot be empty
- customerId must be alphanumeric
- Status fields updated by background services

*HTTP Status Codes:*
- 200 OK - Successful operation
- 201 Created - Order successfully created
- 400 Bad Request - Invalid request data
- 404 Not Found - Order not found
- 500 Internal Server Error - Server processing error

*Service Details:*
- Port: 8082
- No authentication required (internal service)
- Content-Type: application/json

= Task 8: BPEL Process Implementation

== Spring Integration vs BPEL

*Implementation Decision:*
Used Spring Integration instead of traditional BPEL for modern orchestration.

*Justification:*
- BPEL engines (Apache ODE) are deprecated
- Spring Integration provides equivalent functionality
- Better cloud-native deployment
- Easier testing and maintenance
- Industry standard for microservice orchestration

== "PlaceOrder" Process Flow

```
Order Request → JWT Validation → Catalog Lookup → Order Creation → Async Processing
     ↓              ↓               ↓              ↓              ↓
[REST/SOAP] → [Auth Filter] → [Book Details] → [Order Queue] → [Payment/Shipping]
```

*Spring Integration Implementation:*
```java
@Bean
public IntegrationFlow orderProcessingFlow() {
    return IntegrationFlows
        .from("orderInputChannel")
        .log("Starting order processing")
        .handle("catalogServiceHandler", "enrichOrderWithBookDetails")
        .log("Book details enriched")
        .channel("orderChannel")
        .get();
}
```

*Process Steps:*
1. *Receive*: REST/SOAP order request
2. *Validate*: JWT token authentication  
3. *Enrich*: Catalog service lookup for book details
4. *Queue*: Send to order processing queue
5. *Reply*: Immediate confirmation to client

= Task 9: BPEL Engine Deployment

== Spring Integration Deployment

*Modern Approach:*
- Embedded in Order Orchestration Service (port 8086)
- No separate BPEL engine required
- Built as a Spring Boot application deployment

*Benefits over Traditional BPEL:*
- Container-ready deployment
- Cloud-native scaling
- Integrated health monitoring
- Better DevOps pipeline support

*Testing and Monitoring:*
- Actuator endpoints for health checks
- Message flow tracking
- Performance metrics collection
- Error handling and compensation

= Task 10: Integration Services

== Payment Service and Shipping Service Integration via RabbitMQ

*Integration Architecture:*

#align(center)[
  #image("images/order-process-flow.png", width: 100%)
]

== Payment Service Integration

*RabbitMQ Integration Points:*
- *Consumes from*: `payment.queue` - receives payment processing requests
- *Publishes to*: `paymentconfirm.queue` - sends payment completion status
- *Publishes to*: `shipping.queue` - triggers shipping after successful payment

*Integration Flow:*
- Payment service receives order payment data from queue
- Processes payment transaction with 2-second processing delay
- Sends payment confirmation back to system
- Automatically triggers shipping workflow upon successful payment

*Key Files:*
- `payments-service/src/main/java/.../PaymentProcessor.java` - RabbitMQ listener
- `payments-service/src/main/java/.../RabbitConfig.java` - Queue configuration
- `payments-service/src/main/resources/application.properties` - RabbitMQ connection

== Shipping Service Integration  

*RabbitMQ Integration Points:*
- *Consumes from*: `shipping.queue` - receives shipment initiation requests
- *Publishes to*: `shippingconfirm.queue` - sends shipment confirmation and tracking

*Integration Flow:*
- Shipping service receives order data after payment completion
- Creates shipment record with tracking number generation
- Processes shipping with 3-second handling delay
- Sends shipping confirmation back to system for final status update

*Key Files:*
- `shipping-service/src/main/java/.../ShippingProcessor.java` - RabbitMQ listener
- `shipping-service/src/main/java/.../RabbitConfig.java` - Queue configuration  
- `shipping-service/src/main/resources/application.properties` - RabbitMQ connection

== Message-Driven Integration Benefits

*Asynchronous Processing:*
- Services operate independently without blocking calls
- Payment and shipping can process at their own pace
- System remains responsive during heavy processing loads

*Service Decoupling:*
- No direct HTTP calls between payment and shipping services
- Each service only knows about queue contracts, not service internals
- Easy to replace or upgrade individual services

*Reliability and Resilience:*
- RabbitMQ ensures message persistence and delivery
- Failed messages can be retried or sent to dead letter queues
- Services can restart without losing pending work

*Scalability:*
- Multiple instances of payment/shipping services can process same queues
- Load automatically distributed across available service instances
- Independent scaling based on queue depth and processing requirements

= Task 11: Error Handling Strategy

== Dead Letter Queue Implementation

*Error Handling Approach:*
- *Retry Logic*: 3 attempts with exponential backoff (5s, 25s, 125s)
- *Dead Letter Queue*: Failed messages route to DLQ
- *Manual Recovery*: Operations team can reprocess failures

*Implementation:*
```java
@RabbitListener(queues = "order.queue")
public void processOrder(Map orderData) {
    try {
        processOrderLogic(orderData);
    } catch (Exception e) {
        log.error("Processing failed: {}", e.getMessage());
        throw new AmqpRejectAndDontRequeueException("Send to DLQ", e);
    }
}
```

*Error Types:*
- Validation errors → Immediate rejection
- Processing failures → Retry then DLQ
- Service unavailable → Circuit breaker pattern

= Task 12: WS-Security Configuration

== Current Implementation Status

*Reality Check:*
WS-Security NOT implemented due to time constraints.

*Current SOAP Security:*
- Development mode with hardcoded "SOAP-CLIENT-TOKEN"
- No WS-Security header processing
- Direct endpoint access without authentication

*Planned Implementation:*
```xml
<!-- Would require WSS4J configuration -->
<wsse:Security soap:mustUnderstand="true">
    <wsse:UsernameToken>
        <wsse:Username>service_client</wsse:Username>
        <wsse:Password Type="PasswordDigest">hash</wsse:Password>
    </wsse:UsernameToken>
</wsse:Security>
```

*Technical Requirements for Future:*
- Apache WSS4J dependencies
- Callback handlers for authentication
- Policy configuration
- Certificate management

*Justification:*
- WS-Security complexity beyond available timeframe
- Core SOA functionality prioritized

= Task 13: Authentication Implementation for Order Services

== JWT Authentication Implementation for Order Processing

*Implementation Architecture:*
- Orders Service (port 8082): No direct authentication (internal service)
- Order Orchestration Service (port 8086): JWT-secured REST endpoints
- Auth Server (port 8081): JWT token generation and validation

== JWT Token Generation Process

*Authentication Flow:*
- User registers/authenticates with Auth Server
- Auth Server generates JWT token using HS256 algorithm
- Client includes JWT token in Authorization header for order processing
- Orchestration Service validates token before processing orders

*Key Implementation Files:*
- `auth-server/src/main/java/com/globalbooks/auth/security/JwtUtil.java` - Token generation
- `auth-server/src/main/java/com/globalbooks/auth/security/JwtRequestFilter.java` - Token validation
- `auth-server/src/main/java/com/globalbooks/auth/config/SecurityConfig.java` - Security configuration
- `auth-server/src/main/java/com/globalbooks/auth/controller/AuthController.java` - Authentication endpoints

== JWT Token Characteristics

*Security Features:*
- Algorithm: HS256 (HMAC with SHA-256)
- Secret Key: Auto-generated SecretKey for signing
- Expiration: 10 hours (36,000,000 ms)
- Claims: Subject (username), issued-at, expiration
- Stateless: No server-side session storage

*Token Structure:*
- Header: Algorithm and token type
- Payload: Username, issued time, expiration
- Signature: HMAC SHA-256 with secret key

== Order Service Security Implementation

*Orders Service (Port 8082):*
- No authentication required (internal microservice)
- Accessed only by orchestration service and queue consumers
- Protected by service-to-service communication patterns

*Order Orchestration Service (Port 8086):*
- JWT authentication required for `/api/orders/process` endpoint
- Authorization header: `Authorization: Bearer {jwt_token}`
- Token validation through Spring Security filter chain
- Protected endpoints return 401/403 for invalid/missing tokens

*Implementation Files:*
- `order-orchestration-service/src/main/java/com/globalbooks/orchestration/service/AuthenticationService.java` - Token validation
- `order-orchestration-service/src/main/resources/application.properties` - Auth service configuration

== Security Validation Process

*Token Validation Steps:*
- Extract Bearer token from Authorization header
- Parse JWT token to extract username and claims
- Validate token signature using secret key
- Check token expiration date
- Load user details and set security context
- Allow/deny request based on validation result

*Error Handling:*
- Missing token: 401 Unauthorized
- Invalid token: 401 Unauthorized
- Expired token: 401 Unauthorized
- Malformed token: 400 Bad Request

*Testing Evidence:*
- `tests/test-2-rest-order.sh` - Demonstrates JWT authentication flow
- Successful authentication returns order processing confirmation
- Unauthorized requests properly rejected with 401 status

= Task 14: QoS Mechanisms

== Reliable Messaging

*RabbitMQ QoS Configuration:*
- *Persistent Messages*: Survive broker restarts
- *Publisher Confirms*: Acknowledgment of message delivery
- *Consumer Acknowledgments*: Manual message acknowledgment
- *Durable Queues*: Queue persistence across restarts

*Implementation:*
```java
@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate template = new RabbitTemplate(connectionFactory);
    template.setConfirmCallback((correlationData, ack, cause) -> {
        if (!ack) log.error("Message delivery failed: {}", cause);
    });
    return template;
}
```

*QoS Features:*
- At-least-once delivery guarantee
- Message ordering preservation
- Flow control with prefetch limits
- Connection recovery mechanisms

= Task 15: Governance Policy

== Versioning Strategy

*URL Conventions:*
- REST: `/api/v1/orders`, `/api/v2/orders`
- SOAP: Namespace versioning `http://globalbooks.com/catalog/v1`
- Backward compatibility: 12-month support

*Change Management:*
- Minor changes: Additive, same version
- Major changes: Breaking changes, new version
- Deprecation: 6-month notice period

== SLA Targets

*Availability:*
- *Production SLA*: 99.5% uptime (3.6 hours downtime/month max)
- *Response Time*: Sub-200ms for catalog lookups
- *Throughput*: 1000 concurrent orders during peak

*Monitoring:*
- Health endpoints: `/health`, `/actuator/health`
- APM integration for performance tracking
- Automated alerting for SLA violations

== Deprecation Plan

*Timeline:*
1. *6 months*: Deprecation notice
2. *3 months*: Migration assistance
3. *Sunset*: Complete version removal

*Process:*
- Developer notifications
- Migration documentation
- Support during transition
- Emergency support for critical systems

= Task 16: Cloud Platform Deployment

== Current Deployment Status

*Local Environment:*
- 6 services running on ports 8081-8086
- RabbitMQ via Docker Compose
- H2 in-memory databases
- Health monitoring enabled

*Cloud-Ready Architecture:*
```
Service Distribution:
Auth(8081) → Orders(8082) → Payments(8083)
    ↓           ↓              ↓
Shipping(8084) → Catalog(8085) → Orchestration(8086)
    ↓           ↓              ↓
        RabbitMQ Message Broker
```

*Containerization Ready:*
- Spring Boot JAR packaging
- Externalized configuration
- Environment variable support
- Docker-friendly design

*Cloud Migration Path:*
- *AWS*: ECS/Fargate + RDS + SQS + ALB
- *Kubernetes*: Service mesh + ConfigMaps + Ingress
- *Scaling*: Horizontal scaling via load balancers
- *Security*: HTTPS/TLS + secret management

*Production Checklist:*
- SSL certificate configuration
- Database migration (H2 → PostgreSQL)
- Centralized logging (ELK/CloudWatch)
- CI/CD pipeline integration

= Implementation Summary

== Coursework Tasks Completion

*Completed Tasks:*
- All SOA design principles applied
- Service decomposition with justification
- WSDL and SOAP implementation
- REST API with proper JSON schema
- Modern orchestration (Spring Integration)
- Message queue integration
- JWT authentication implementation
- Quality of service mechanisms
- Comprehensive governance policy
- Cloud-ready deployment architecture

*Technical Compromises:*
- WS-Security: Not implemented (time/complexity)
- UDDI: Modern service discovery approach
- BPEL: Spring Integration (industry standard)
- OAuth2: JWT sufficient for architecture

*Deliverables Available:*
- Complete source code
- WSDL/XSD schemas
- Configuration files
- Test suites
- Documentation

== Architecture Validation

*SOA Principles Demonstrated:*
- Service autonomy with independent data stores
- Loose coupling via message queues
- Contract-first development (SOAP)
- Protocol independence (REST + SOAP)
- Service composition and orchestration

*Production Readiness:*
- Comprehensive testing framework
- Health monitoring and error handling
- Scalable architecture design
- Security implementation
- Governance policies defined

---

*End of Doc*
